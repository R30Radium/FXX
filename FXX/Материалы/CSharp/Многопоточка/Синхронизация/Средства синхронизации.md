
### 1. **Lock**

`lock` — это ключевое слово, которое используется для обеспечения эксклюзивного доступа к коду или ресурсу. Оно предотвращает одновременный доступ к критической секции кода несколькими потоками.

``` C#

private readonly object _lockObject = new object();

public void SomeMethod() 
{
	lock(_lockObject) 
	{
		// Код, который должен выполняться только одним потоком одновременно
	}
}

```

Используйте `lock`, когда вам нужно обеспечить эксклюзивный доступ к критическому разделу кода в рамках одного процесса. По сути, `lock` - это лишь синтаксический сахар (вызывает методы `Monitor.Enter` и `Monitor.Exit`)

### 2. **Monitor**
`Monitor`: класс `Monitor` предоставляет методы для управления блокировками. Например, метод `Enter` используется для захвата блокировки, а метод `Exit` - для ее освобождения

```C#



```

Используйте `Monitor`, когда вам нужно обеспечить эксклюзивный доступ к критическому разделу кода в рамках одного процесса, но вам также нужны дополнительные возможности, такие как ожидание условия. Использование блока `finally` для освобождения блокировки является важным, поскольку это гарантирует ее освобождение, даже если в процессе выполнения критической секции возникает исключение.

### 3. **Mutex**
`Mutex` - это примитив синхронизации, который также может быть использован для синхронизации потоков между различными процессами.

Пример: 

```C#



```

Используйте `Mutex`, когда вам нужно обеспечить эксклюзивный доступ к критическому разделу кода между несколькими процессами.  Mutex может быть использован в нескольких процессах, позволяя синхронизировать потоки, работающие в разных процессах.

### 4. **Semaphore**

`Semaphore` позволяет ограничивать количество потоков, которые могут иметь доступ к ресурсу или пулу ресурсов одновременно.

```C#



```

Используйте `Semaphore`, когда вам нужно ограничить количество потоков, которые могут одновременно получить доступ к ресурсу.

##4.1 **SemaphoreSlim**
`SemaphoreSlim` — это более легковесная версия, используемая в рамках одного процесса.

``` C#



```

### 5. **AutoResetEvent и ManualResetEvent**

Семейство классов `ManualResetEvent` и `AutoResetEvent` в C# предоставляет функциональность для управления потоками с помощью сигналов или событий. Оба этих класса позволяют оповещать один или несколько потоков о наступлении определенного условия.

`ManualResetEvent`:  
`ManualResetEvent` имеет два основных состояния: сигнализированное (`true`) и невыполненное (`false`). Он достаточно гибкий, так как после отправки сигнала он может оставаться в сигнализированном состоянии (`true`), пока его явно не переведут в невыполненное состояние (`false`). Множество потоков может ждать этого объекта `ManualResetEvent`. Когда он находится в сигнализированном состоянии, все соответствующие потоки продолжают свое выполнение.

`AutoResetEvent`:  
В отличие от `ManualResetEvent`, `AutoResetEvent` автоматически переходит из сигнализированного состояния (`true`) в невыполненное состояние (`false`), когда любой ожидающий поток получает сигнал. Это означает, что каждый раз, когда поток получает сигнал, другие потоки будут продолжать выполнение, только если он также ожидает события.

В обоих случаях классы `ManualResetEvent` и `AutoResetEvent` предоставляют следующие методы:

- `Set()`: Устанавливает состояние события в сигнальное (`true`), что приводит к продолжению всех ожидающих потоков.
    
- `Reset()`: Сбрасывает состояние события в невыполненное (`false`).
    
- `WaitOne()`: Блокирует текущий поток до получения сигнала от события.
    
- `WaitOne(timeout)`: Блокирует текущий поток до получения сигнала от события или истечения указанного времени ожидания.
    

Практическое использование `ManualResetEvent` и `AutoResetEvent` возможно в различных сценариях. Например:

- Координация между процессами для начала/завершения операций.
    
- Ожидание наступления определенного условия перед выполнением действий в нескольких потоках.
    
- Синхронизация доступа к ресурсам и контроль параллельных операций.
    

Классы из этого семейства могут быть полезными при создании многопоточных приложений для управления и синхронизации взаимодействия между потоками.

Рассмотрим пример работы AutoResetEvent:

``` C#



```


### 6. **Barrier**

`Barrier` позволяет нескольким потокам работать вместе на различных фазах вычислительного процесса.

```C#



```

### 7. **Concurrent Collections**

Этот класс позволяет потоку ждать, пока не будет достигнуто определенное количество сигналов от других потоков.

``` C#

private static CountdownEvent countdown = new CountdownEvent(2); //Два сигнала

// В каждом потоке 
countdown.Signal(); // Сигнал о том, что этот поток завершил работу

// В ожидающем потоке 
countdown.Wait(); // Ожидание обоих сигналов

```

### 8. **Concurrent Collections**

Для работы с коллекциями в многопоточной среде можно использовать специальные коллекции, такие как `ConcurrentDictionary`, `ConcurrentBag`, `ConcurrentQueue` и `ConcurrentStack`, которые обеспечивают безопасный доступ из нескольких потоков.



