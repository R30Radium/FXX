## Deadlock(взаимоблокировка)

**Deadlock (взаимоблокировка)** — это ситуация, когда как минимум два потока останавливаются и ожидают друг от друга снятия блокировки.

Поскольку оба потока ожидают друг от друга выполнения соответствующего действия, получается, что они блокируют друг друга, из-за чего их ожидание может длиться бесконечно. Есть несколько советов, которые помогут вам избежать такой проблемы как deadlock:

**1. Избегайте блокировки нескольких ресурсов**:

Если это возможно, старайтесь минимизировать использование блокировок нескольких ресурсов одновременно. Если два потока блокируют разные ресурсы и требуют доступа к обоим, может возникнуть взаимоблокировка. Рассмотрите возможность пересмотра архитектуры вашего кода, чтобы уменьшить количество блокировок.

**2. Упорядочивайте блокировки**:

Если вам все же нужно блокировать несколько ресурсов, упорядочивайте блокировки таким образом, чтобы они выполнялись в одном и том же порядке во всех потоках. Это поможет предотвратить взаимоблокировку. Обязательно документируйте этот порядок, чтобы другие разработчики знали о нем и следовали ему(если вы работаете в команде)

Приведем пример программы, где нарушен порядок блокировок:

```
class Program
{
    static object lock1 = new object();
    static object lock2 = new object();

    static void Main(string[] args)
    {
        Thread thread1 = new Thread(DoWork1);
        Thread thread2 = new Thread(DoWork2);

        thread1.Start();
        thread2.Start();

        thread1.Join();
        thread2.Join();
    }

    static void DoWork1()
    {
        lock (lock1)
        {
            Thread.Sleep(1000);
            lock (lock2)
            {
                Console.WriteLine("Thread 1: Working...");
            }
        }
    }

    static void DoWork2()
    {
        lock (lock2)
        {
            Thread.Sleep(1000);
            lock (lock1)
            {
                Console.WriteLine("Thread 2: Working...");
            }
        }
    }
}
```

Вот как это будет выглядеть в консоли отладки:

![](https://habrastorage.org/getpro/habr/upload_files/8b8/a0f/176/8b8a0f176b19c2b15e805264b7a5a2a8.png)

Очевидно, что что-то пошло не так, поскольку второй поток начинает работать раньше первого. В чем же проблема? Проблема данного кода заключается в том, что оба потока пытаются захватить lock1, а затем lock2, что приводит к взаимной блокировке (deadlock). Когда поток 1 захватывает lock1 и ждет 1 секунду, поток 2, в свою очередь, блокирует lock1, чтобы выполнить свою работу. После этого он пытается захватить lock2, который уже захвачен потоком 1. Таким образом, поток 1 ждет освобождения lock2, но он не может быть освобожден, поскольку поток 2 ждет освобождения lock1 - это и есть взаимная блокировка

Чтобы избежать взаимоблокировки нужно просто изменить порядок блокировки так, чтобы он был одинаковым в обоих методах DoWork1 и DoWork2:

```
class Program
{
    static object lock1 = new object();
    static object lock2 = new object();

    static void Main(string[] args)
    {
        Thread thread1 = new Thread(DoWork1);
        Thread thread2 = new Thread(DoWork2);

        thread1.Start();
        thread2.Start();

        thread1.Join();
        thread2.Join();
    }

    static void DoWork1()
    {
        lock (lock1)
        {
            Thread.Sleep(1000);
            lock (lock2)
            {
                Console.WriteLine("Thread 1: Working...");
            }
        }
    }

    static void DoWork2()
    {
        lock (lock1)
        {
            Thread.Sleep(1000);
            lock (lock2)
            {
                Console.WriteLine("Thread 2: Working...");
            }
        }
    }
}
```

Для защиты от взаимной блокировки (deadlock) в методах `DoWork1` и `DoWork2` блокируется только один из объектов `lock1` или `lock2`, а затем блокируется второй объект внутри первой блокировки. Это гарантирует, что потоки не будут блокировать друг друга, так как они будут последовательно блокировать объекты.

Таким образом, данный код защищен от взаимной блокировки(deadlock) и будет корректно компилироваться:

![](https://habrastorage.org/getpro/habr/upload_files/80b/eaf/01a/80beaf01a38ad3065221187cba7f6f49.png)

**3. Избегайте длительного удержания блокировки:**

Длительное удержание блокировки в многопоточных приложениях может привести к дедлоку. Для избежания этой проблемы, важно правильно управлять блокировками. Важно убедиться, что вы снимаете блокировку, когда она вам больше не нужна. Для этого можно использовать конструкцию `try-finally`. Приведем пример:

```
object lockObject = new object();

Monitor.Enter(lockObject);
try
{
    // Выполнение защищенного кода
}
finally
{
    Monitor.Exit(lockObject); // снятие блокировки в случае возникновения исключения
}
```

Этот пример показывает, как можно использовать конструкцию `try-finally`, чтобы гарантировать, что блокировка будет снята даже в случае возникновения исключения.