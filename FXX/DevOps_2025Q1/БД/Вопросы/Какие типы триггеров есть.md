
Триггеры в SQL бывают:
1. **По времени**: BEFORE (до операции), AFTER (после), INSTEAD OF (вместо).
2. **По событию**: INSERT, UPDATE, DELETE.
3. **По уровню**: ROW-LEVEL (для каждой строки), STATEMENT-LEVEL (для всей операции).
4. **По типу**: DML (для данных), DDL (для метаданных).
5. **По месту**: Для таблиц или представлений (VIEW). 

Пример: BEFORE INSERT триггер проверяет данные перед вставкой, AFTER UPDATE логирует изменения.

В SQL, включая PostgreSQL, **триггеры** — это специальные процедуры, которые автоматически выполняются при наступлении определенных событий в базе данных (например, вставка, обновление или удаление данных). Триггеры могут быть классифицированы по нескольким критериям. Давайте рассмотрим основные типы триггеров.

---

### 1. **По времени срабатывания (Timing)**:
Триггеры могут срабатывать **до** или **после** события.

#### a) **BEFORE**
- Срабатывает **до** выполнения операции (например, до вставки, обновления или удаления строки).
- Используется для проверки или изменения данных перед их сохранением в таблице.
- Пример: Проверка корректности данных перед вставкой.

#### b) **AFTER**
- Срабатывает **после** выполнения операции.
- Используется для выполнения действий после изменения данных (например, логирование или обновление связанных таблиц).
- Пример: Логирование изменений в отдельной таблице.

#### c) **INSTEAD OF** (в некоторых СУБД, например, PostgreSQL для представлений)
- Срабатывает **вместо** выполнения операции.
- Используется для представлений (views), где операции вставки, обновления или удаления не могут быть выполнены напрямую.
- Пример: Замена операции вставки в представлении на вставку в базовые таблицы.

---

### 2. **По событию (Event)**:
Триггеры могут срабатывать при различных операциях с данными.

#### a) **INSERT**
- Срабатывает при вставке новой строки в таблицу.

#### b) **UPDATE**
- Срабатывает при обновлении существующей строки в таблице.

#### c) **DELETE**
- Срабатывает при удалении строки из таблицы.

#### d) **TRUNCATE** (в некоторых СУБД)
- Срабатывает при выполнении команды `TRUNCATE`, которая удаляет все строки из таблицы.

---

### 3. **По уровню (Level)**:
Триггеры могут срабатывать для каждой строки или для всей операции.

#### a) **ROW-LEVEL (построчные)**
- Срабатывает для **каждой строки**, затронутой операцией.
- Пример: Если обновляется 10 строк, триггер сработает 10 раз.

#### b) **STATEMENT-LEVEL (операционные)**
- Срабатывает **один раз** для всей операции, независимо от количества затронутых строк.
- Пример: Если обновляется 10 строк, триггер сработает 1 раз.

---

### 4. **По типу данных (Data vs. DDL)**:
Триггеры могут работать с данными (DML) или с метаданными (DDL).

#### a) **DML Triggers (Data Manipulation Language)**
- Срабатывают при операциях с данными: `INSERT`, `UPDATE`, `DELETE`.
- Пример: Триггер, который логирует изменения в таблице.

#### b) **DDL Triggers (Data Definition Language)**
- Срабатывают при операциях с метаданными: `CREATE`, `ALTER`, `DROP`.
- Пример: Триггер, который отслеживает создание новых таблиц.

---

### 5. **По месту срабатывания**:
Триггеры могут быть привязаны к таблицам или представлениям.

#### a) **Табличные триггеры**
- Срабатывают при операциях с таблицами.

#### b) **Триггеры для представлений (VIEW)**
- Срабатывают при операциях с представлениями (обычно `INSTEAD OF` триггеры).

---

### Примеры триггеров в PostgreSQL:

#### 1. **BEFORE INSERT триггер**
```sql
CREATE FUNCTION check_data() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.age < 0 THEN
        RAISE EXCEPTION 'Возраст не может быть отрицательным';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_insert_trigger
BEFORE INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION check_data();
```

#### 2. **AFTER UPDATE триггер**
```sql
CREATE FUNCTION log_changes() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data)
    VALUES ('users', 'UPDATE', OLD, NEW);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_update_trigger
AFTER UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION log_changes();
```

#### 3. **INSTEAD OF триггер для представления**
```sql
CREATE FUNCTION insert_into_view() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO users (name, age) VALUES (NEW.name, NEW.age);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER instead_of_insert_trigger
INSTEAD OF INSERT ON user_view
FOR EACH ROW
EXECUTE FUNCTION insert_into_view();
```

---

### Итог:
Триггеры в SQL делятся на:
- **По времени**: BEFORE, AFTER, INSTEAD OF.
- **По событию**: INSERT, UPDATE, DELETE, TRUNCATE.
- **По уровню**: ROW-LEVEL, STATEMENT-LEVEL.
- **По типу данных**: DML, DDL.
- **По месту срабатывания**: Табличные, для представлений.

Триггеры — мощный инструмент для автоматизации задач в базе данных, но их следует использовать с осторожностью, чтобы избежать сложностей в поддержке и производительности.
